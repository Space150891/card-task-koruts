{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/cubex/www/koruts/TASKS/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useReadClassState = useReadClassState;\n\nvar _lodash = require(\"lodash\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _fixtureState = require(\"../../../fixtureState\");\n\nvar _FixtureContext = require(\"../../FixtureContext\");\n\nvar _findRelevantElementPaths = require(\"../shared/findRelevantElementPaths\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n} // How often to check the state of the loaded component and update the fixture\n// state if it changed\n\n\nvar REFRESH_INTERVAL = 200;\n\nfunction useReadClassState(fixture, decoratorId, elRefs) {\n  var elPaths = (0, _findRelevantElementPaths.findRelevantElementPaths)(fixture);\n\n  var _React$useContext = _react.default.useContext(_FixtureContext.FixtureContext),\n      fixtureState = _React$useContext.fixtureState,\n      setFixtureState = _React$useContext.setFixtureState;\n\n  var timeoutId = _react.default.useRef(null);\n\n  _react.default.useEffect(function () {\n    // The check should run even if no element paths are found at mount, because\n    // the fixture can change during the lifecycle of a FixtureCapture instance\n    // and the updated fixture might contain elements of stateful components\n    scheduleStateCheck();\n    return function () {\n      if (timeoutId.current) {\n        clearTimeout(timeoutId.current);\n      }\n    };\n  });\n\n  function scheduleStateCheck() {\n    // Is there a better way to listen to component state changes?\n    timeoutId.current = window.setTimeout(checkState, REFRESH_INTERVAL);\n  }\n\n  function checkState() {\n    var fixtureStateChangeScheduled = false;\n    Object.keys(elRefs.current).map( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(elPath) {\n        var state, elementId, fsClassState;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(elPaths.indexOf(elPath) === -1)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"[FixtureCapture] Child ref exists for missing element path \\\"\".concat(elPath, \"\\\"\"));\n\n              case 2:\n                state = elRefs.current[elPath].state;\n                elementId = {\n                  decoratorId: decoratorId,\n                  elPath: elPath\n                };\n                fsClassState = (0, _fixtureState.findFixtureStateClassState)(fixtureState, elementId);\n\n                if (fsClassState && state && !doesFixtureStateMatchClassState(fsClassState, state)) {\n                  fixtureStateChangeScheduled = true;\n                  setFixtureState(function (prevFs) {\n                    return _objectSpread(_objectSpread({}, prevFs), {}, {\n                      classState: (0, _fixtureState.updateFixtureStateClassState)({\n                        fixtureState: prevFs,\n                        elementId: elementId,\n                        values: (0, _fixtureState.createValues)(state)\n                      })\n                    });\n                  });\n                }\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    if (!fixtureStateChangeScheduled) {\n      scheduleStateCheck();\n    }\n  }\n}\n\nfunction doesFixtureStateMatchClassState(fsClassState, state) {\n  return (0, _lodash.isEqual)(state, (0, _fixtureState.extendWithValues)(state, fsClassState.values));\n}","map":{"version":3,"sources":["/home/cubex/www/koruts/TASKS/node_modules/react-cosmos-shared2/dist/FixtureLoader/FixtureCapture/classState/useReadClassState.js"],"names":["Object","defineProperty","exports","value","useReadClassState","_lodash","require","_react","_interopRequireDefault","_fixtureState","_FixtureContext","_findRelevantElementPaths","obj","__esModule","default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","_asyncToGenerator","fn","self","args","err","undefined","REFRESH_INTERVAL","fixture","decoratorId","elRefs","elPaths","findRelevantElementPaths","_React$useContext","useContext","FixtureContext","fixtureState","setFixtureState","timeoutId","useRef","useEffect","scheduleStateCheck","current","clearTimeout","window","setTimeout","checkState","fixtureStateChangeScheduled","map","_ref","mark","_callee","elPath","state","elementId","fsClassState","wrap","_callee$","_context","prev","next","indexOf","Error","concat","findFixtureStateClassState","doesFixtureStateMatchClassState","prevFs","classState","updateFixtureStateClassState","values","createValues","stop","_x","isEqual","extendWithValues"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useReadClassState = useReadClassState;\n\nvar _lodash = require(\"lodash\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _fixtureState = require(\"../../../fixtureState\");\n\nvar _FixtureContext = require(\"../../FixtureContext\");\n\nvar _findRelevantElementPaths = require(\"../shared/findRelevantElementPaths\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n// How often to check the state of the loaded component and update the fixture\n// state if it changed\nvar REFRESH_INTERVAL = 200;\n\nfunction useReadClassState(fixture, decoratorId, elRefs) {\n  var elPaths = (0, _findRelevantElementPaths.findRelevantElementPaths)(fixture);\n\n  var _React$useContext = _react.default.useContext(_FixtureContext.FixtureContext),\n      fixtureState = _React$useContext.fixtureState,\n      setFixtureState = _React$useContext.setFixtureState;\n\n  var timeoutId = _react.default.useRef(null);\n\n  _react.default.useEffect(function () {\n    // The check should run even if no element paths are found at mount, because\n    // the fixture can change during the lifecycle of a FixtureCapture instance\n    // and the updated fixture might contain elements of stateful components\n    scheduleStateCheck();\n    return function () {\n      if (timeoutId.current) {\n        clearTimeout(timeoutId.current);\n      }\n    };\n  });\n\n  function scheduleStateCheck() {\n    // Is there a better way to listen to component state changes?\n    timeoutId.current = window.setTimeout(checkState, REFRESH_INTERVAL);\n  }\n\n  function checkState() {\n    var fixtureStateChangeScheduled = false;\n    Object.keys(elRefs.current).map( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(elPath) {\n        var state, elementId, fsClassState;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(elPaths.indexOf(elPath) === -1)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"[FixtureCapture] Child ref exists for missing element path \\\"\".concat(elPath, \"\\\"\"));\n\n              case 2:\n                state = elRefs.current[elPath].state;\n                elementId = {\n                  decoratorId: decoratorId,\n                  elPath: elPath\n                };\n                fsClassState = (0, _fixtureState.findFixtureStateClassState)(fixtureState, elementId);\n\n                if (fsClassState && state && !doesFixtureStateMatchClassState(fsClassState, state)) {\n                  fixtureStateChangeScheduled = true;\n                  setFixtureState(function (prevFs) {\n                    return _objectSpread(_objectSpread({}, prevFs), {}, {\n                      classState: (0, _fixtureState.updateFixtureStateClassState)({\n                        fixtureState: prevFs,\n                        elementId: elementId,\n                        values: (0, _fixtureState.createValues)(state)\n                      })\n                    });\n                  });\n                }\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    if (!fixtureStateChangeScheduled) {\n      scheduleStateCheck();\n    }\n  }\n}\n\nfunction doesFixtureStateMatchClassState(fsClassState, state) {\n  return (0, _lodash.isEqual)(state, (0, _fixtureState.extendWithValues)(state, fsClassState.values));\n}"]},"metadata":{},"sourceType":"script"}