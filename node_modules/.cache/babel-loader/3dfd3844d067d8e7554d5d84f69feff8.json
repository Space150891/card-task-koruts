{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getElementAtPath = getElementAtPath;\nexports.getExpectedElementAtPath = getExpectedElementAtPath;\n\nvar _lodash = require(\"lodash\");\n\nvar _react = require(\"../../../../react\");\n\nvar _shared = require(\"./shared\"); // Why be silent about trying to fetch a node that isn't an element?\n// Because users of this utility only care about elements. Whether the child\n// node was removed or replaced by a different type of node (eg. string,\n// array of elements, etc.) is irrelevant.\n// NICETOHAVE: Assert child path validity\n\n\nfunction getElementAtPath(node, elPath) {\n  if (!(0, _react.isReactElement)(node) && !Array.isArray(node)) {\n    return null;\n  }\n\n  var rootNode = node;\n  var childNode = (0, _shared.isRootPath)(elPath) ? rootNode : (0, _lodash.get)(rootNode, elPath);\n\n  if (!(0, _react.isReactElement)(childNode)) {\n    return null;\n  }\n\n  return childNode;\n}\n\nfunction getExpectedElementAtPath(node, elPath) {\n  var el = getElementAtPath(node, elPath);\n\n  if (!el) {\n    throw new Error(\"Element not found at path: \".concat(elPath));\n  }\n\n  return el;\n}","map":{"version":3,"sources":["/home/cubex/www/koruts/TASKS/node_modules/react-cosmos-shared2/dist/FixtureLoader/FixtureCapture/shared/nodeTree/getElementAtPath.js"],"names":["Object","defineProperty","exports","value","getElementAtPath","getExpectedElementAtPath","_lodash","require","_react","_shared","node","elPath","isReactElement","Array","isArray","rootNode","childNode","isRootPath","get","el","Error","concat"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B;AACAF,OAAO,CAACG,wBAAR,GAAmCA,wBAAnC;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,QAAD,CAArB;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,mBAAD,CAApB;;AAEA,IAAIE,OAAO,GAAGF,OAAO,CAAC,UAAD,CAArB,C,CAEA;AACA;AACA;AACA;AACA;;;AACA,SAASH,gBAAT,CAA0BM,IAA1B,EAAgCC,MAAhC,EAAwC;AACtC,MAAI,CAAC,CAAC,GAAGH,MAAM,CAACI,cAAX,EAA2BF,IAA3B,CAAD,IAAqC,CAACG,KAAK,CAACC,OAAN,CAAcJ,IAAd,CAA1C,EAA+D;AAC7D,WAAO,IAAP;AACD;;AAED,MAAIK,QAAQ,GAAGL,IAAf;AACA,MAAIM,SAAS,GAAG,CAAC,GAAGP,OAAO,CAACQ,UAAZ,EAAwBN,MAAxB,IAAkCI,QAAlC,GAA6C,CAAC,GAAGT,OAAO,CAACY,GAAZ,EAAiBH,QAAjB,EAA2BJ,MAA3B,CAA7D;;AAEA,MAAI,CAAC,CAAC,GAAGH,MAAM,CAACI,cAAX,EAA2BI,SAA3B,CAAL,EAA4C;AAC1C,WAAO,IAAP;AACD;;AAED,SAAOA,SAAP;AACD;;AAED,SAASX,wBAAT,CAAkCK,IAAlC,EAAwCC,MAAxC,EAAgD;AAC9C,MAAIQ,EAAE,GAAGf,gBAAgB,CAACM,IAAD,EAAOC,MAAP,CAAzB;;AAEA,MAAI,CAACQ,EAAL,EAAS;AACP,UAAM,IAAIC,KAAJ,CAAU,8BAA8BC,MAA9B,CAAqCV,MAArC,CAAV,CAAN;AACD;;AAED,SAAOQ,EAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getElementAtPath = getElementAtPath;\nexports.getExpectedElementAtPath = getExpectedElementAtPath;\n\nvar _lodash = require(\"lodash\");\n\nvar _react = require(\"../../../../react\");\n\nvar _shared = require(\"./shared\");\n\n// Why be silent about trying to fetch a node that isn't an element?\n// Because users of this utility only care about elements. Whether the child\n// node was removed or replaced by a different type of node (eg. string,\n// array of elements, etc.) is irrelevant.\n// NICETOHAVE: Assert child path validity\nfunction getElementAtPath(node, elPath) {\n  if (!(0, _react.isReactElement)(node) && !Array.isArray(node)) {\n    return null;\n  }\n\n  var rootNode = node;\n  var childNode = (0, _shared.isRootPath)(elPath) ? rootNode : (0, _lodash.get)(rootNode, elPath);\n\n  if (!(0, _react.isReactElement)(childNode)) {\n    return null;\n  }\n\n  return childNode;\n}\n\nfunction getExpectedElementAtPath(node, elPath) {\n  var el = getElementAtPath(node, elPath);\n\n  if (!el) {\n    throw new Error(\"Element not found at path: \".concat(elPath));\n  }\n\n  return el;\n}"]},"metadata":{},"sourceType":"script"}