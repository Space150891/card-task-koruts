{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValues = createValues;\nexports.createValue = createValue;\n\nvar _reactElementToJsxString = _interopRequireDefault(require(\"react-element-to-jsx-string\"));\n\nvar _reactIs = require(\"react-is\");\n\nvar _shared = require(\"./shared\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction createValues(obj) {\n  var values = {};\n  Object.keys(obj).forEach(function (key) {\n    values[key] = createValue(obj[key]);\n  });\n  return values;\n}\n\nfunction createValue(value) {\n  if ((0, _shared.isPrimitiveValue)(value)) {\n    return {\n      type: 'primitive',\n      value: value\n    };\n  }\n\n  if ((0, _shared.isArray)(value)) {\n    return {\n      type: 'array',\n      values: value.map(function (v) {\n        return createValue(v);\n      })\n    };\n  }\n\n  if ((0, _shared.isObject)(value)) {\n    return {\n      type: 'object',\n      values: createValues(value)\n    };\n  } // Why store unserializable values in fixture state?\n  // - Because they still provides value in the Cosmos UI. They let the user know\n  //   that, eg. a prop, is present and see the read-only stringified value.\n  // - More importantly, because the fixture state controls which props to render.\n  //   This way, if a prop is read-only and cannot be edited in the UI, it can\n  //   still be removed.\n\n\n  return {\n    type: 'unserializable',\n    stringifiedValue: stringifyUnserializableValue(value)\n  };\n}\n\nfunction stringifyUnserializableValue(value) {\n  // TODO: Enable custom stringifier plugins\n  return (0, _reactIs.isElement)(value) ? (0, _reactElementToJsxString.default)(value) : String(value);\n}","map":{"version":3,"sources":["/home/cubex/www/koruts/TASKS/node_modules/react-cosmos-shared2/dist/fixtureState/createValues.js"],"names":["Object","defineProperty","exports","value","createValues","createValue","_reactElementToJsxString","_interopRequireDefault","require","_reactIs","_shared","obj","__esModule","default","values","keys","forEach","key","isPrimitiveValue","type","isArray","map","v","isObject","stringifiedValue","stringifyUnserializableValue","isElement","String"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,YAAR,GAAuBA,YAAvB;AACAF,OAAO,CAACG,WAAR,GAAsBA,WAAtB;;AAEA,IAAIC,wBAAwB,GAAGC,sBAAsB,CAACC,OAAO,CAAC,6BAAD,CAAR,CAArD;;AAEA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AAEA,IAAIE,OAAO,GAAGF,OAAO,CAAC,UAAD,CAArB;;AAEA,SAASD,sBAAT,CAAgCI,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;;AAE/F,SAASP,YAAT,CAAsBO,GAAtB,EAA2B;AACzB,MAAIG,MAAM,GAAG,EAAb;AACAd,EAAAA,MAAM,CAACe,IAAP,CAAYJ,GAAZ,EAAiBK,OAAjB,CAAyB,UAAUC,GAAV,EAAe;AACtCH,IAAAA,MAAM,CAACG,GAAD,CAAN,GAAcZ,WAAW,CAACM,GAAG,CAACM,GAAD,CAAJ,CAAzB;AACD,GAFD;AAGA,SAAOH,MAAP;AACD;;AAED,SAAST,WAAT,CAAqBF,KAArB,EAA4B;AAC1B,MAAI,CAAC,GAAGO,OAAO,CAACQ,gBAAZ,EAA8Bf,KAA9B,CAAJ,EAA0C;AACxC,WAAO;AACLgB,MAAAA,IAAI,EAAE,WADD;AAELhB,MAAAA,KAAK,EAAEA;AAFF,KAAP;AAID;;AAED,MAAI,CAAC,GAAGO,OAAO,CAACU,OAAZ,EAAqBjB,KAArB,CAAJ,EAAiC;AAC/B,WAAO;AACLgB,MAAAA,IAAI,EAAE,OADD;AAELL,MAAAA,MAAM,EAAEX,KAAK,CAACkB,GAAN,CAAU,UAAUC,CAAV,EAAa;AAC7B,eAAOjB,WAAW,CAACiB,CAAD,CAAlB;AACD,OAFO;AAFH,KAAP;AAMD;;AAED,MAAI,CAAC,GAAGZ,OAAO,CAACa,QAAZ,EAAsBpB,KAAtB,CAAJ,EAAkC;AAChC,WAAO;AACLgB,MAAAA,IAAI,EAAE,QADD;AAELL,MAAAA,MAAM,EAAEV,YAAY,CAACD,KAAD;AAFf,KAAP;AAID,GAtByB,CAsBxB;AACF;AACA;AACA;AACA;AACA;;;AAGA,SAAO;AACLgB,IAAAA,IAAI,EAAE,gBADD;AAELK,IAAAA,gBAAgB,EAAEC,4BAA4B,CAACtB,KAAD;AAFzC,GAAP;AAID;;AAED,SAASsB,4BAAT,CAAsCtB,KAAtC,EAA6C;AAC3C;AACA,SAAO,CAAC,GAAGM,QAAQ,CAACiB,SAAb,EAAwBvB,KAAxB,IAAiC,CAAC,GAAGG,wBAAwB,CAACO,OAA7B,EAAsCV,KAAtC,CAAjC,GAAgFwB,MAAM,CAACxB,KAAD,CAA7F;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValues = createValues;\nexports.createValue = createValue;\n\nvar _reactElementToJsxString = _interopRequireDefault(require(\"react-element-to-jsx-string\"));\n\nvar _reactIs = require(\"react-is\");\n\nvar _shared = require(\"./shared\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createValues(obj) {\n  var values = {};\n  Object.keys(obj).forEach(function (key) {\n    values[key] = createValue(obj[key]);\n  });\n  return values;\n}\n\nfunction createValue(value) {\n  if ((0, _shared.isPrimitiveValue)(value)) {\n    return {\n      type: 'primitive',\n      value: value\n    };\n  }\n\n  if ((0, _shared.isArray)(value)) {\n    return {\n      type: 'array',\n      values: value.map(function (v) {\n        return createValue(v);\n      })\n    };\n  }\n\n  if ((0, _shared.isObject)(value)) {\n    return {\n      type: 'object',\n      values: createValues(value)\n    };\n  } // Why store unserializable values in fixture state?\n  // - Because they still provides value in the Cosmos UI. They let the user know\n  //   that, eg. a prop, is present and see the read-only stringified value.\n  // - More importantly, because the fixture state controls which props to render.\n  //   This way, if a prop is read-only and cannot be edited in the UI, it can\n  //   still be removed.\n\n\n  return {\n    type: 'unserializable',\n    stringifiedValue: stringifyUnserializableValue(value)\n  };\n}\n\nfunction stringifyUnserializableValue(value) {\n  // TODO: Enable custom stringifier plugins\n  return (0, _reactIs.isElement)(value) ? (0, _reactElementToJsxString.default)(value) : String(value);\n}"]},"metadata":{},"sourceType":"script"}