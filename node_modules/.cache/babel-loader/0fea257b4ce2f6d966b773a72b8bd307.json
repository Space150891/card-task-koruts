{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useFixtureState = useFixtureState;\n\nvar _lodash = require(\"lodash\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _fixtureState = require(\"../../../fixtureState\");\n\nvar _react2 = require(\"../../../react\");\n\nvar _FixtureContext = require(\"../../FixtureContext\");\n\nvar _findRelevantElementPaths = require(\"../shared/findRelevantElementPaths\");\n\nvar _decorateFixtureRefs = require(\"./decorateFixtureRefs\");\n\nvar _shared = require(\"./shared\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction useFixtureState(fixture, decoratorId, elRefs) {\n  var elPaths = (0, _findRelevantElementPaths.findRelevantElementPaths)(fixture);\n\n  var _React$useContext = _react.default.useContext(_FixtureContext.FixtureContext),\n      fixtureState = _React$useContext.fixtureState,\n      setFixtureState = _React$useContext.setFixtureState;\n\n  var lastFixtureState = useFixtureStateRef(fixtureState); // Keep a copy of the previous fixture state to observe changes\n\n  var prevFixtureState = _react.default.useRef(fixtureState); // Remember initial state of child components to use as a default when\n  // resetting fixture state\n\n\n  var initialStates = _react.default.useRef({}); // Ref handlers are reused because every time we pass a new ref handler to\n  // a React element it gets called in the next render loop, even when the\n  // associated element instance has been preserved. Having ref handlers fire\n  // on every render loop results in unwanted operations and race conditions.\n\n\n  var cachedRefHandlers = _react.default.useRef({});\n\n  _react.default.useEffect(function () {\n    return function () {\n      initialStates.current = {};\n      cachedRefHandlers.current = {};\n    };\n  }, []);\n\n  _react.default.useEffect(function () {\n    // Remove fixture state for removed child elements (likely via HMR)\n    // FIXME: Also invalidate fixture state at this element path if the\n    // component type of the corresponding element changed\n    var fsProps = (0, _fixtureState.getFixtureStateClassState)(fixtureState, decoratorId);\n    fsProps.forEach(function (_ref) {\n      var elementId = _ref.elementId;\n      var elPath = elementId.elPath;\n\n      if (elPaths.indexOf(elementId.elPath) === -1) {\n        setFixtureState(function (prevFs) {\n          return _objectSpread(_objectSpread({}, prevFs), {}, {\n            classState: (0, _fixtureState.removeFixtureStateClassState)(fixtureState, elementId)\n          });\n        });\n\n        if (elRefs.current[elPath]) {\n          delete elRefs.current[elPath];\n          delete initialStates.current[elPath];\n          delete cachedRefHandlers.current[elPath];\n        }\n      }\n    });\n    elPaths.forEach(function (elPath) {\n      var elementId = {\n        decoratorId: decoratorId,\n        elPath: elPath\n      }; // Component fixture state can be provided before the fixture mounts (eg.\n      // a previous snapshot of a fixture state or the current fixture state\n      // from another renderer)\n\n      var fsClassState = (0, _fixtureState.findFixtureStateClassState)(fixtureState, elementId);\n\n      if (!fsClassState) {\n        if (initialStates.current[elPath]) {\n          var state = initialStates.current[elPath].state;\n          var elRef = elRefs.current[elPath];\n\n          if (!(0, _lodash.isEqual)(elRef.state, state)) {\n            (0, _shared.replaceState)(elRef, state);\n          }\n\n          setFixtureState(function (prevFs) {\n            return _objectSpread(_objectSpread({}, prevFs), {}, {\n              classState: (0, _fixtureState.createFixtureStateClassState)({\n                fixtureState: prevFs,\n                elementId: elementId,\n                values: (0, _fixtureState.createValues)(state),\n                componentName: (0, _react2.getComponentName)(elRef.constructor)\n              })\n            });\n          });\n        }\n      } else {\n        var _elRef = elRefs.current[elPath]; // The el ref can be missing for three reasons:\n        //   1. Element type is stateless\n        //   2. Element type is a class, but doesn't have state. An instance exists\n        //      but has been discarded because of its lack of state.\n        //   3. Element instance unmounted and is about to remount. When this\n        //      happens, the new instance will be handled when its ref fires again.\n\n        if (!_elRef) {\n          return;\n        } // The child's state can be out of sync with the fixture state for two\n        // reasons:\n        //   1. The child's state changed internally\n        //   2. The fixture state changed\n        // Here we're interested in the second scenario. In the first scenario\n        // we want to let the component state override the fixture state.\n\n\n        var prevFsClassState = (0, _fixtureState.findFixtureStateClassState)(prevFixtureState.current, elementId);\n\n        if (prevFsClassState && !(0, _lodash.isEqual)(prevFsClassState, fsClassState)) {\n          return (0, _shared.replaceState)(_elRef, (0, _fixtureState.extendWithValues)(_elRef.state, fsClassState.values));\n        }\n      }\n    });\n  }, [decoratorId, elPaths, elRefs, fixtureState, fixtureState.classState, setFixtureState]); // Update prev fixture state ref *after* running effects that reference it\n\n\n  _react.default.useEffect(function () {\n    prevFixtureState.current = fixtureState;\n  });\n\n  return (0, _decorateFixtureRefs.decorateFixtureRefs)(fixture, handleRef, cachedRefHandlers.current);\n\n  function handleRef(elPath, elRef) {\n    if (!elRef) {\n      delete elRefs.current[elPath];\n      return;\n    } // Only track instances with state\n\n\n    var state = elRef.state;\n\n    if (!state) {\n      return;\n    }\n\n    elRefs.current[elPath] = elRef;\n    setInitialState(initialStates.current, elPath, elRef);\n    var elementId = {\n      decoratorId: decoratorId,\n      elPath: elPath\n    };\n    var fsClassState = (0, _fixtureState.findFixtureStateClassState)(lastFixtureState.current, elementId);\n\n    if (!fsClassState) {\n      setFixtureState(function (prevFs) {\n        return _objectSpread(_objectSpread({}, prevFs), {}, {\n          classState: (0, _fixtureState.createFixtureStateClassState)({\n            fixtureState: prevFs,\n            elementId: elementId,\n            values: (0, _fixtureState.createValues)(state),\n            componentName: (0, _react2.getComponentName)(elRef.constructor)\n          })\n        });\n      });\n    } else {\n      (0, _shared.replaceState)(elRef, (0, _fixtureState.extendWithValues)(state, fsClassState.values));\n    }\n  }\n} // Make latest fixture state accessible in ref callback\n\n\nfunction useFixtureStateRef(fixtureState) {\n  var ref = _react.default.useRef(fixtureState);\n\n  _react.default.useEffect(function () {\n    ref.current = fixtureState;\n  });\n\n  return ref;\n}\n\nfunction setInitialState(initialStates, elPath, elRef) {\n  var found = initialStates[elPath];\n  var type = elRef.constructor; // Keep the first state recevied for this type\n\n  var initialStateExists = found && found.type === type;\n\n  if (!initialStateExists && elRef.state) {\n    initialStates[elPath] = {\n      type: type,\n      state: elRef.state\n    };\n  }\n}","map":{"version":3,"sources":["/home/cubex/www/koruts/TASKS/node_modules/react-cosmos-shared2/dist/FixtureLoader/FixtureCapture/classState/useFixtureState.js"],"names":["Object","defineProperty","exports","value","useFixtureState","_lodash","require","_react","_interopRequireDefault","_fixtureState","_react2","_FixtureContext","_findRelevantElementPaths","_decorateFixtureRefs","_shared","obj","__esModule","default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","fixture","decoratorId","elRefs","elPaths","findRelevantElementPaths","_React$useContext","useContext","FixtureContext","fixtureState","setFixtureState","lastFixtureState","useFixtureStateRef","prevFixtureState","useRef","initialStates","cachedRefHandlers","useEffect","current","fsProps","getFixtureStateClassState","_ref","elementId","elPath","indexOf","prevFs","classState","removeFixtureStateClassState","fsClassState","findFixtureStateClassState","state","elRef","isEqual","replaceState","createFixtureStateClassState","values","createValues","componentName","getComponentName","constructor","_elRef","prevFsClassState","extendWithValues","decorateFixtureRefs","handleRef","setInitialState","ref","found","type","initialStateExists"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useFixtureState = useFixtureState;\n\nvar _lodash = require(\"lodash\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _fixtureState = require(\"../../../fixtureState\");\n\nvar _react2 = require(\"../../../react\");\n\nvar _FixtureContext = require(\"../../FixtureContext\");\n\nvar _findRelevantElementPaths = require(\"../shared/findRelevantElementPaths\");\n\nvar _decorateFixtureRefs = require(\"./decorateFixtureRefs\");\n\nvar _shared = require(\"./shared\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction useFixtureState(fixture, decoratorId, elRefs) {\n  var elPaths = (0, _findRelevantElementPaths.findRelevantElementPaths)(fixture);\n\n  var _React$useContext = _react.default.useContext(_FixtureContext.FixtureContext),\n      fixtureState = _React$useContext.fixtureState,\n      setFixtureState = _React$useContext.setFixtureState;\n\n  var lastFixtureState = useFixtureStateRef(fixtureState); // Keep a copy of the previous fixture state to observe changes\n\n  var prevFixtureState = _react.default.useRef(fixtureState); // Remember initial state of child components to use as a default when\n  // resetting fixture state\n\n\n  var initialStates = _react.default.useRef({}); // Ref handlers are reused because every time we pass a new ref handler to\n  // a React element it gets called in the next render loop, even when the\n  // associated element instance has been preserved. Having ref handlers fire\n  // on every render loop results in unwanted operations and race conditions.\n\n\n  var cachedRefHandlers = _react.default.useRef({});\n\n  _react.default.useEffect(function () {\n    return function () {\n      initialStates.current = {};\n      cachedRefHandlers.current = {};\n    };\n  }, []);\n\n  _react.default.useEffect(function () {\n    // Remove fixture state for removed child elements (likely via HMR)\n    // FIXME: Also invalidate fixture state at this element path if the\n    // component type of the corresponding element changed\n    var fsProps = (0, _fixtureState.getFixtureStateClassState)(fixtureState, decoratorId);\n    fsProps.forEach(function (_ref) {\n      var elementId = _ref.elementId;\n      var elPath = elementId.elPath;\n\n      if (elPaths.indexOf(elementId.elPath) === -1) {\n        setFixtureState(function (prevFs) {\n          return _objectSpread(_objectSpread({}, prevFs), {}, {\n            classState: (0, _fixtureState.removeFixtureStateClassState)(fixtureState, elementId)\n          });\n        });\n\n        if (elRefs.current[elPath]) {\n          delete elRefs.current[elPath];\n          delete initialStates.current[elPath];\n          delete cachedRefHandlers.current[elPath];\n        }\n      }\n    });\n    elPaths.forEach(function (elPath) {\n      var elementId = {\n        decoratorId: decoratorId,\n        elPath: elPath\n      }; // Component fixture state can be provided before the fixture mounts (eg.\n      // a previous snapshot of a fixture state or the current fixture state\n      // from another renderer)\n\n      var fsClassState = (0, _fixtureState.findFixtureStateClassState)(fixtureState, elementId);\n\n      if (!fsClassState) {\n        if (initialStates.current[elPath]) {\n          var state = initialStates.current[elPath].state;\n          var elRef = elRefs.current[elPath];\n\n          if (!(0, _lodash.isEqual)(elRef.state, state)) {\n            (0, _shared.replaceState)(elRef, state);\n          }\n\n          setFixtureState(function (prevFs) {\n            return _objectSpread(_objectSpread({}, prevFs), {}, {\n              classState: (0, _fixtureState.createFixtureStateClassState)({\n                fixtureState: prevFs,\n                elementId: elementId,\n                values: (0, _fixtureState.createValues)(state),\n                componentName: (0, _react2.getComponentName)(elRef.constructor)\n              })\n            });\n          });\n        }\n      } else {\n        var _elRef = elRefs.current[elPath]; // The el ref can be missing for three reasons:\n        //   1. Element type is stateless\n        //   2. Element type is a class, but doesn't have state. An instance exists\n        //      but has been discarded because of its lack of state.\n        //   3. Element instance unmounted and is about to remount. When this\n        //      happens, the new instance will be handled when its ref fires again.\n\n        if (!_elRef) {\n          return;\n        } // The child's state can be out of sync with the fixture state for two\n        // reasons:\n        //   1. The child's state changed internally\n        //   2. The fixture state changed\n        // Here we're interested in the second scenario. In the first scenario\n        // we want to let the component state override the fixture state.\n\n\n        var prevFsClassState = (0, _fixtureState.findFixtureStateClassState)(prevFixtureState.current, elementId);\n\n        if (prevFsClassState && !(0, _lodash.isEqual)(prevFsClassState, fsClassState)) {\n          return (0, _shared.replaceState)(_elRef, (0, _fixtureState.extendWithValues)(_elRef.state, fsClassState.values));\n        }\n      }\n    });\n  }, [decoratorId, elPaths, elRefs, fixtureState, fixtureState.classState, setFixtureState]); // Update prev fixture state ref *after* running effects that reference it\n\n\n  _react.default.useEffect(function () {\n    prevFixtureState.current = fixtureState;\n  });\n\n  return (0, _decorateFixtureRefs.decorateFixtureRefs)(fixture, handleRef, cachedRefHandlers.current);\n\n  function handleRef(elPath, elRef) {\n    if (!elRef) {\n      delete elRefs.current[elPath];\n      return;\n    } // Only track instances with state\n\n\n    var state = elRef.state;\n\n    if (!state) {\n      return;\n    }\n\n    elRefs.current[elPath] = elRef;\n    setInitialState(initialStates.current, elPath, elRef);\n    var elementId = {\n      decoratorId: decoratorId,\n      elPath: elPath\n    };\n    var fsClassState = (0, _fixtureState.findFixtureStateClassState)(lastFixtureState.current, elementId);\n\n    if (!fsClassState) {\n      setFixtureState(function (prevFs) {\n        return _objectSpread(_objectSpread({}, prevFs), {}, {\n          classState: (0, _fixtureState.createFixtureStateClassState)({\n            fixtureState: prevFs,\n            elementId: elementId,\n            values: (0, _fixtureState.createValues)(state),\n            componentName: (0, _react2.getComponentName)(elRef.constructor)\n          })\n        });\n      });\n    } else {\n      (0, _shared.replaceState)(elRef, (0, _fixtureState.extendWithValues)(state, fsClassState.values));\n    }\n  }\n} // Make latest fixture state accessible in ref callback\n\n\nfunction useFixtureStateRef(fixtureState) {\n  var ref = _react.default.useRef(fixtureState);\n\n  _react.default.useEffect(function () {\n    ref.current = fixtureState;\n  });\n\n  return ref;\n}\n\nfunction setInitialState(initialStates, elPath, elRef) {\n  var found = initialStates[elPath];\n  var type = elRef.constructor; // Keep the first state recevied for this type\n\n  var initialStateExists = found && found.type === type;\n\n  if (!initialStateExists && elRef.state) {\n    initialStates[elPath] = {\n      type: type,\n      state: elRef.state\n    };\n  }\n}"]},"metadata":{},"sourceType":"script"}